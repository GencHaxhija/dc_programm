# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SnipperDockWidget
                                 A QGIS plugin
 Erm√∂glicht einen spezifischen Bereich auszuw√§hlen im richtigen Massstab.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-11-10
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Genc Haxhija/ Liam Diener
        email                : genc.haxhija@stud.hslu.ch
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import json
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt, QSize, QRectF, QPointF
from qgis.PyQt.QtXml import QDomDocument
from qgis.core import (
    QgsProject, QgsMapSettings, QgsRectangle, QgsWkbTypes, QgsGeometry, 
    QgsPointXY, QgsPrintLayout, QgsLayoutItemMap, QgsLayoutItemScaleBar, 
    QgsLayoutItemPicture, QgsLayoutExporter, QgsLayoutPoint, QgsUnitTypes,
    QgsLayoutSize, QgsLayoutItemLabel, QgsLayoutItemLegend, QgsLayoutItemPolyline,
    QgsLegendStyle, QgsReadWriteContext
)
from qgis.utils import iface
from qgis.gui import QgsMapTool, QgsRubberBand
from qgis.PyQt.QtGui import QCursor, QColor, QPolygonF

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'DC_Programm_dockwidget_base.ui'))

class LayerSelectDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Export Einstellungen")
        self.setMinimumWidth(500)
        self.setMinimumHeight(650)
        self.layout = QtWidgets.QVBoxLayout(self)
        
        # --- Mode Selection ---
        self.gb_mode = QtWidgets.QGroupBox("Export Modus")
        self.mode_layout = QtWidgets.QHBoxLayout(self.gb_mode)
        self.rb_batch = QtWidgets.QRadioButton("Einzel-Export (Batch)")
        self.rb_overlay = QtWidgets.QRadioButton("Overlay-Export (Basis + X)")
        self.rb_layout = QtWidgets.QRadioButton("Layout-Bogen (√úbersicht A3)")
        self.rb_dxf = QtWidgets.QRadioButton("DXF Export (CAD)")
        self.rb_batch.setChecked(True)
        self.mode_layout.addWidget(self.rb_batch)
        self.mode_layout.addWidget(self.rb_overlay)
        self.mode_layout.addWidget(self.rb_layout)
        self.mode_layout.addWidget(self.rb_dxf)
        self.layout.addWidget(self.gb_mode)
        
        # --- Page Size Selection (only for Batch & Overlay) ---
        self.gb_page_size = QtWidgets.QGroupBox("Seitengr√∂√üe")
        page_size_layout = QtWidgets.QVBoxLayout(self.gb_page_size)
        
        # Dropdown for predefined formats
        h_format = QtWidgets.QHBoxLayout()
        h_format.addWidget(QtWidgets.QLabel("Format:"))
        self.combo_page_format = QtWidgets.QComboBox()
        self.combo_page_format.addItem("Standard (150 x 120 mm)", (150, 120))
        self.combo_page_format.addItem("A4 Querformat (297 x 210 mm)", (297, 210))
        self.combo_page_format.addItem("A4 Hochformat (210 x 297 mm)", (210, 297))
        self.combo_page_format.addItem("A3 Querformat (420 x 297 mm)", (420, 297))
        self.combo_page_format.addItem("A3 Hochformat (297 x 420 mm)", (297, 420))
        h_format.addWidget(self.combo_page_format)
        page_size_layout.addLayout(h_format)
        
        # Custom size checkbox + input fields
        self.check_custom_size = QtWidgets.QCheckBox("Benutzerdefiniert")
        self.check_custom_size.stateChanged.connect(self.toggle_custom_size)
        page_size_layout.addWidget(self.check_custom_size)
        
        h_custom = QtWidgets.QHBoxLayout()
        h_custom.addWidget(QtWidgets.QLabel("Breite:"))
        self.spin_width = QtWidgets.QSpinBox()
        self.spin_width.setRange(50, 1000)
        self.spin_width.setValue(150)
        self.spin_width.setSuffix(" mm")
        self.spin_width.setEnabled(False)
        h_custom.addWidget(self.spin_width)
        
        h_custom.addWidget(QtWidgets.QLabel("H√∂he:"))
        self.spin_height = QtWidgets.QSpinBox()
        self.spin_height.setRange(50, 1000)
        self.spin_height.setValue(120)
        self.spin_height.setSuffix(" mm")
        self.spin_height.setEnabled(False)
        h_custom.addWidget(self.spin_height)
        page_size_layout.addLayout(h_custom)
        
        self.layout.addWidget(self.gb_page_size)
        
        # Connect mode changes to show/hide page size
        self.rb_batch.toggled.connect(self.update_page_size_visibility)
        self.rb_overlay.toggled.connect(self.update_page_size_visibility)
        self.rb_layout.toggled.connect(self.update_page_size_visibility)
        self.rb_dxf.toggled.connect(self.update_page_size_visibility)
        
        # Initially hide if not batch/overlay
        self.update_page_size_visibility()
        
        # Get all layers and filter out those without names
        all_project_layers = QgsProject.instance().mapLayers().values()
        self.all_layers = sorted([l for l in all_project_layers if l.name().strip()], key=lambda l: l.name())
        
        # --- Batch Selection UI ---
        self.widget_batch = QtWidgets.QWidget()
        batch_layout = QtWidgets.QVBoxLayout(self.widget_batch)
        batch_layout.addWidget(QtWidgets.QLabel("<b>Layer ausw√§hlen (Mehrfachwahl):</b>"))
        
        self.batch_checks = []
        
        scroll_batch = QtWidgets.QScrollArea()
        scroll_batch.setWidgetResizable(True)
        scroll_content_batch = QtWidgets.QWidget()
        scroll_layout_batch = QtWidgets.QVBoxLayout(scroll_content_batch)
        
        for layer in self.all_layers:
            cb = QtWidgets.QCheckBox(layer.name(), self)
            cb.layer_id = layer.id()
            scroll_layout_batch.addWidget(cb)
            self.batch_checks.append(cb)
            
        scroll_batch.setWidget(scroll_content_batch)
        batch_layout.addWidget(scroll_batch)
        
        # Mode-specific buttons (bottom)
        self.btn_area_batch = QtWidgets.QPushButton("üìç  Bereich markieren")
        self.btn_area_batch.clicked.connect(lambda: self.parent().on_area_select_mode("batch"))
        batch_layout.addWidget(self.btn_area_batch)
        
        self.btn_export_batch = QtWidgets.QPushButton("üì§ Exportieren")
        self.btn_export_batch.clicked.connect(lambda: self.parent().on_export_mode("batch"))
        self.btn_export_batch.setEnabled(False)
        batch_layout.addWidget(self.btn_export_batch)
        
        self.layout.addWidget(self.widget_batch)
        
        # --- Overlay Selection UI ---
        self.widget_overlay = QtWidgets.QWidget()
        overlay_layout = QtWidgets.QVBoxLayout(self.widget_overlay)
        
        # Base Layer
        overlay_layout.addWidget(QtWidgets.QLabel("<b>Basis-Layer (100%):</b>"))
        self.combo_base = QtWidgets.QComboBox()
        for layer in self.all_layers:
            self.combo_base.addItem(layer.name(), layer.id())
        overlay_layout.addWidget(self.combo_base)
        
        # Overlay Layers (Multi-Select)
        overlay_layout.addWidget(QtWidgets.QLabel("<b>Overlay-Layer (Mehrfachwahl):</b>"))
        self.overlay_checks = []
        
        scroll_overlay = QtWidgets.QScrollArea()
        scroll_overlay.setWidgetResizable(True)
        scroll_content_overlay = QtWidgets.QWidget()
        scroll_layout_overlay = QtWidgets.QVBoxLayout(scroll_content_overlay)
        
        for layer in self.all_layers:
            cb = QtWidgets.QCheckBox(layer.name(), self)
            cb.layer_id = layer.id()
            scroll_layout_overlay.addWidget(cb)
            self.overlay_checks.append(cb)
            
        scroll_overlay.setWidget(scroll_content_overlay)
        overlay_layout.addWidget(scroll_overlay)
        
        # Opacity
        h_opacity = QtWidgets.QHBoxLayout()
        h_opacity.addWidget(QtWidgets.QLabel("Overlay Transparenz:"))
        self.spin_opacity = QtWidgets.QSpinBox()
        self.spin_opacity.setRange(0, 100)
        self.spin_opacity.setValue(60)
        self.spin_opacity.setSuffix(" %")
        h_opacity.addWidget(self.spin_opacity)
        overlay_layout.addLayout(h_opacity)
        
        # Mode-specific buttons (bottom)
        self.btn_area_overlay = QtWidgets.QPushButton("üìç Bereich markieren")
        self.btn_area_overlay.clicked.connect(lambda: self.parent().on_area_select_mode("overlay"))
        overlay_layout.addWidget(self.btn_area_overlay)
        
        self.btn_export_overlay = QtWidgets.QPushButton("üì§ Exportieren")
        self.btn_export_overlay.clicked.connect(lambda: self.parent().on_export_mode("overlay"))
        self.btn_export_overlay.setEnabled(False)
        overlay_layout.addWidget(self.btn_export_overlay)
        
        self.layout.addWidget(self.widget_overlay)
        self.widget_overlay.hide()
        
        # --- Layout Overview UI ---
        self.widget_layout = QtWidgets.QWidget()
        layout_form = QtWidgets.QVBoxLayout(self.widget_layout)
        
        # Template Selection
        layout_form.addWidget(QtWidgets.QLabel("<b>Layout-Vorlage (.qpt):</b>"))
        h_tmpl = QtWidgets.QHBoxLayout()
        self.line_template = QtWidgets.QLineEdit()
        self.line_template.setPlaceholderText("Standard (Automatisch generiert)")
        self.btn_template = QtWidgets.QPushButton("...")
        self.btn_template.setFixedWidth(30)
        self.btn_template.clicked.connect(self.select_template)
        h_tmpl.addWidget(self.line_template)
        h_tmpl.addWidget(self.btn_template)
        layout_form.addLayout(h_tmpl)

        # Base Layer (for Layout Export)
        layout_form.addWidget(QtWidgets.QLabel("<b>Basis-Layer (Hintergrund):</b>"))
        self.combo_base_layout = QtWidgets.QComboBox()
        for layer in self.all_layers:
            self.combo_base_layout.addItem(layer.name(), layer.id())
        layout_form.addWidget(self.combo_base_layout)

        # Overlay Layers (Layout Mode) - EXPLICIT DROPDOWNS
        layout_form.addWidget(QtWidgets.QLabel("<b>Overlay-Layer Zuweisung:</b>"))
        
        self.map_combos = []
        grid_overlays = QtWidgets.QGridLayout()
        
        # Create 8 Combos
        for i in range(8):
            lbl = QtWidgets.QLabel(f"MainMap {i+1}:")
            combo = QtWidgets.QComboBox()
            combo.addItem("- Leer -", None)
            for layer in self.all_layers:
                combo.addItem(layer.name(), layer.id())
            
            self.map_combos.append(combo)
            
            # Grid layout: 2 columns
            row = i // 2
            col = (i % 2) * 2 # Label, Combo, Label, Combo
            
            grid_overlays.addWidget(lbl, row, col)
            grid_overlays.addWidget(combo, row, col+1)
            
        layout_form.addLayout(grid_overlays)

        # Text Inputs
        layout_form.addWidget(QtWidgets.QLabel("<b>Beschriftung:</b>"))
        form_info = QtWidgets.QFormLayout()
        
        self.edit_kuerzel = QtWidgets.QLineEdit()
        self.edit_kuerzel.setPlaceholderText("Gez: K√ºrzel / Gep: K√ºrzelGepr√ºft")
        
        self.edit_date = QtWidgets.QLineEdit()
        self.edit_date.setPlaceholderText("Dat.: Datum / Rev.")
        
        self.edit_title = QtWidgets.QLineEdit()
        self.edit_title.setPlaceholderText("Projektnummer/Projekttitel")
        
        self.edit_project_name = QtWidgets.QLineEdit()
        self.edit_project_name.setPlaceholderText("Projektname")
        
        self.edit_document_name = QtWidgets.QLineEdit()
        self.edit_document_name.setPlaceholderText("Name der exportierten Datei (ohne Endung)")
        
        form_info.addRow("Gez:", self.edit_kuerzel)
        form_info.addRow("Dat:", self.edit_date)
        form_info.addRow("Title:", self.edit_title)
        form_info.addRow("Projekt Name:", self.edit_project_name)
        form_info.addRow("Dokument Name:", self.edit_document_name)
        
        layout_form.addLayout(form_info)

        # Opacity (Layout Mode)
        h_opacity_layout = QtWidgets.QHBoxLayout()
        h_opacity_layout.addWidget(QtWidgets.QLabel("Overlay Transparenz:"))
        self.spin_opacity_layout = QtWidgets.QSpinBox()
        self.spin_opacity_layout.setRange(0, 100)
        self.spin_opacity_layout.setValue(60)
        self.spin_opacity_layout.setSuffix(" %")
        h_opacity_layout.addWidget(self.spin_opacity_layout)
        layout_form.addLayout(h_opacity_layout)
        
        # Debug Mode
        self.check_debug = QtWidgets.QCheckBox("Layout √∂ffnen ohne Datei zu speichern")
        self.check_debug.setChecked(False)
        layout_form.addWidget(self.check_debug)
        
        # Mode-specific buttons (bottom)
        self.btn_area_layout = QtWidgets.QPushButton("üìç Bereich markieren")
        self.btn_area_layout.clicked.connect(lambda: self.parent().on_area_select_mode("layout"))
        layout_form.addWidget(self.btn_area_layout)
        
        self.btn_export_layout = QtWidgets.QPushButton("üì§ Exportieren")
        self.btn_export_layout.clicked.connect(lambda: self.parent().on_export_mode("layout"))
        self.btn_export_layout.setEnabled(False)
        layout_form.addWidget(self.btn_export_layout)
        
        self.layout.addWidget(self.widget_layout)
        self.widget_layout.hide()

        # --- DXF Export UI ---
        self.widget_dxf = QtWidgets.QWidget()
        dxf_layout = QtWidgets.QVBoxLayout(self.widget_dxf)
        
        dxf_layout.addWidget(QtWidgets.QLabel("<b>Vektor-Layer f√ºr DXF-Export (max. 5):</b>"))
        
        # Create scrollable list with checkboxes for all vector layers
        from qgis.core import QgsVectorLayer
        vector_layers = [layer for layer in self.all_layers if isinstance(layer, QgsVectorLayer)]
        
        # QListWidget for scrollable layer selection
        self.dxf_list = QtWidgets.QListWidget()
        self.dxf_list.setSelectionMode(QtWidgets.QAbstractItemView.MultiSelection)
        self.dxf_list.setMaximumHeight(200)  # Limit height for scrollability
        
        if vector_layers:
            for layer in vector_layers:
                item = QtWidgets.QListWidgetItem(layer.name())
                item.setData(Qt.UserRole, layer.id())  # Store layer ID
                self.dxf_list.addItem(item)
        else:
            item = QtWidgets.QListWidgetItem("Keine Vektor-Layer verf√ºgbar")
            item.setFlags(item.flags() & ~Qt.ItemIsSelectable)
            self.dxf_list.addItem(item)
        
        dxf_layout.addWidget(self.dxf_list)
        
        # Selection counter - updates dynamically
        self.dxf_counter_label = QtWidgets.QLabel(f"<b>Ausgew√§hlt: 0 / 5</b> <i>({len(vector_layers)} verf√ºgbar)</i>")
        dxf_layout.addWidget(self.dxf_counter_label)
        
        # Connect signal to update counter
        self.dxf_list.itemSelectionChanged.connect(self.update_dxf_counter)
        
        # Mode-specific buttons (bottom)
        self.btn_area_dxf = QtWidgets.QPushButton("üìç Bereich markieren")
        self.btn_area_dxf.clicked.connect(lambda: self.parent().on_area_select_mode("dxf"))
        dxf_layout.addWidget(self.btn_area_dxf)
        
        self.btn_export_dxf = QtWidgets.QPushButton("üì§ Exportieren")
        self.btn_export_dxf.clicked.connect(lambda: self.parent().on_export_mode("dxf"))
        self.btn_export_dxf.setEnabled(False)
        dxf_layout.addWidget(self.btn_export_dxf)
        
        self.layout.addWidget(self.widget_dxf)
        self.widget_dxf.hide()

        # --- Common Options ---
        self.gb_opts = QtWidgets.QGroupBox("Optionen")
        opts_layout = QtWidgets.QFormLayout(self.gb_opts)
        
        self.combo_format = QtWidgets.QComboBox()
        self.combo_format.addItems(["PDF", "JPG", "PNG"]) # PDF default for layout
        
        self.combo_dpi = QtWidgets.QComboBox()
        self.combo_dpi.addItems(["150 (Screen)", "300 (Print)", "600 (High Quality)"])
        self.combo_dpi.setCurrentIndex(1) # Default 300
        
        opts_layout.addRow("Format:", self.combo_format)
        opts_layout.addRow("Qualit√§t (DPI):", self.combo_dpi)
        self.layout.addWidget(self.gb_opts)
        
        # --- Progress Bar ---
        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(True)
        self.progress_bar.hide()
        self.layout.addWidget(self.progress_bar)

        # --- Buttons (removed - each mode has its own export button) ---
        # No OK/Cancel buttons needed anymore
        
        # Connect signals
        self.rb_batch.toggled.connect(self.toggle_mode)
        self.rb_overlay.toggled.connect(self.toggle_mode)
        self.rb_layout.toggled.connect(self.toggle_mode)
        self.rb_dxf.toggled.connect(self.toggle_mode)

    def toggle_mode(self):
        if self.rb_batch.isChecked():
            self.widget_batch.show()
            self.widget_overlay.hide()
            self.widget_layout.hide()
            self.widget_dxf.hide()
            self.gb_opts.show()
        elif self.rb_overlay.isChecked():
            self.widget_batch.hide()
            self.widget_overlay.show()
            self.widget_layout.hide()
            self.widget_dxf.hide()
            self.gb_opts.show()
        elif self.rb_layout.isChecked():
            self.widget_batch.hide()
            self.widget_overlay.hide()
            self.widget_layout.show()
            self.widget_dxf.hide()
            self.gb_opts.show()
        elif self.rb_dxf.isChecked():
            self.widget_batch.hide()
            self.widget_overlay.hide()
            self.widget_layout.hide()
            self.widget_dxf.show()
            self.gb_opts.hide()  # No format/DPI options for DXF

    def get_mode(self):
        if self.rb_overlay.isChecked(): return "overlay"
        if self.rb_layout.isChecked(): return "layout"
        if self.rb_dxf.isChecked(): return "dxf"
        return "batch"

    def get_batch_layers(self):
        return [cb.layer_id for cb in self.batch_checks if cb.isChecked()]
    
    def get_dxf_layers(self):
        """Get selected layer IDs for DXF export (max 5)"""
        selected_items = self.dxf_list.selectedItems()
        return [item.data(Qt.UserRole) for item in selected_items if item.data(Qt.UserRole) is not None]
    
    def update_dxf_counter(self):
        """Update DXF selection counter label"""
        count = len(self.dxf_list.selectedItems())
        total_available = self.dxf_list.count()
        
        # Color coding: red if >5, green if 1-5, gray if 0
        if count > 5:
            color = "red"
            status = "‚ö†Ô∏è"
        elif count >= 1:
            color = "green"
            status = "‚úì"
        else:
            color = "gray"
            status = ""
        
        self.dxf_counter_label.setText(
            f"<b style='color:{color};'>{status} Ausgew√§hlt: {count} / 5</b> <i>({total_available} verf√ºgbar)</i>"
        )
        
    def get_layout_config(self):
        # Collect selected IDs from the 8 combos
        selected_overlays = []
        for combo in self.map_combos:
            selected_overlays.append(combo.currentData()) # Can be None
            
        return {
            "kuerzel": self.edit_kuerzel.text(),
            "date": self.edit_date.text(),
            "title": self.edit_title.text(),
            "project_name": self.edit_project_name.text(),
            "document_name": self.edit_document_name.text(),
            "base_id": self.combo_base_layout.currentData(),
            "overlay_ids": selected_overlays, # List of 8 IDs (or None)
            "opacity": self.spin_opacity_layout.value() / 100.0,
            "debug": self.check_debug.isChecked(),
            "template": self.line_template.text()
        }

    def select_template(self):
        default_dir = os.path.join(os.path.dirname(__file__), 'templates')
        if not os.path.exists(default_dir):
            os.makedirs(default_dir)
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Vorlage w√§hlen", default_dir, "QGIS Layout Templates (*.qpt)")
        if fname:
            self.line_template.setText(fname)

    def get_overlay_config(self):
        return {
            "base_id": self.combo_base.currentData(),
            "overlay_ids": [cb.layer_id for cb in self.overlay_checks if cb.isChecked()],
            "opacity": self.spin_opacity.value() / 100.0
        }
        
    def get_format(self):
        return self.combo_format.currentText()
        
    def get_dpi(self):
        txt = self.combo_dpi.currentText() # "300 (Print)"
        return int(txt.split()[0])
    
    def toggle_custom_size(self, state):
        """Enable/disable custom size inputs"""
        is_custom = (state == Qt.Checked)
        self.combo_page_format.setEnabled(not is_custom)
        self.spin_width.setEnabled(is_custom)
        self.spin_height.setEnabled(is_custom)
    
    def update_page_size_visibility(self):
        """Show page size selection only for batch and overlay modes"""
        is_batch_or_overlay = self.rb_batch.isChecked() or self.rb_overlay.isChecked()
        self.gb_page_size.setVisible(is_batch_or_overlay)
    
    def get_page_size(self):
        """Return selected page size as (width, height) tuple in mm"""
        if self.check_custom_size.isChecked():
            return (self.spin_width.value(), self.spin_height.value())
        else:
            return self.combo_page_format.currentData()
        
    def show_progress(self, show=True):
        self.progress_bar.setVisible(show)
        self.btn_box.setEnabled(not show)
        QtWidgets.QApplication.processEvents()
        
    def update_progress(self, value, text=""):
        self.progress_bar.setValue(value)
        if text: self.progress_bar.setFormat(f"%p% - {text}")
        QtWidgets.QApplication.processEvents()

class FixedFrameTool(QgsMapTool):
    def __init__(self, canvas, target_scale, callback, width_mm=150, height_mm=120):
        super().__init__(canvas)
        self.canvas = canvas
        self.target_scale = target_scale
        self.callback = callback
        self.width_mm = width_mm
        self.height_mm = height_mm
        self.rubberBand = None
        self.setCursor(Qt.CrossCursor)
        
    def set_target_scale(self, scale):
        self.target_scale = scale
    
    def set_frame_size(self, width_mm, height_mm):
        """Update frame dimensions"""
        self.width_mm = width_mm
        self.height_mm = height_mm
    
    def canvasMoveEvent(self, event):
        """Show preview rectangle following mouse"""
        center = self.toMapCoordinates(event.pos())
        
        # Calculate rectangle size
        world_width_m = (self.width_mm / 1000.0) * self.target_scale
        world_height_m = (self.height_mm / 1000.0) * self.target_scale
        
        half_width = world_width_m / 2
        half_height = world_height_m / 2
        
        rect = QgsRectangle(
            center.x() - half_width,
            center.y() - half_height,
            center.x() + half_width,
            center.y() + half_height
        )
        
        # Create or update rubber band
        if not self.rubberBand:
            self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
            self.rubberBand.setColor(QColor(255, 0, 0))
            self.rubberBand.setWidth(2)
            self.rubberBand.setFillColor(QColor(255, 64, 0, 40))
        
        self.rubberBand.setToGeometry(QgsGeometry.fromRect(rect), None)
    
    def canvasReleaseEvent(self, event):
        """Place rectangle at current mouse position"""
        center = self.toMapCoordinates(event.pos())
        
        # Calculate final rectangle
        world_width_m = (self.width_mm / 1000.0) * self.target_scale
        world_height_m = (self.height_mm / 1000.0) * self.target_scale
        
        half_width = world_width_m / 2
        half_height = world_height_m / 2
        
        rect = QgsRectangle(
            center.x() - half_width,
            center.y() - half_height,
            center.x() + half_width,
            center.y() + half_height
        )
        
        # Clean up rubber band
        if self.rubberBand:
            self.canvas.scene().removeItem(self.rubberBand)
            self.rubberBand = None
        
        # Send result to callback
        self.callback(rect)
    
    def deactivate(self):
        """Clean up when tool is deactivated"""
        if self.rubberBand:
            self.canvas.scene().removeItem(self.rubberBand)
            self.rubberBand = None
        super().deactivate()

class SnipperDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()
    
    # Konfiguration f√ºr Titel in Layout-Exporten
    TITLE_FONT_FAMILY = "Arial Narrow"  # Schriftart f√ºr Titel √ºber Karten
    TITLE_FONT_SIZE = 12         # Schriftgr√∂√üe f√ºr Titel (in Punkten)


    def __init__(self, parent=None):
        super(SnipperDockWidget, self).__init__(parent)
        self.setupUi(self)
        
        # Hide unused UI elements from template
        if hasattr(self, 'layerComboBox'):
            self.layerComboBox.hide()
            self.layerComboBox.setVisible(False)
            # Try to remove from parent layout if exists
            parent = self.layerComboBox.parent()
            if parent and parent.layout():
                parent.layout().removeWidget(self.layerComboBox)
        
        # Add Scale Selector
        self.scale_combo = QtWidgets.QComboBox()
        self.scale_combo.addItems(["1:200", "1:500", "1:1000", "1:1500", "1:2000", "1:2500", "1:5000"])
        self.scale_combo.setCurrentText("1:500") # Default
        self.scale_combo.currentIndexChanged.connect(self.on_scale_changed)
        
        parent_layout = self.areaSelectButton.parent().layout()
        if parent_layout:
            idx = parent_layout.indexOf(self.areaSelectButton)
            h_layout = QtWidgets.QHBoxLayout()
            h_layout.addWidget(QtWidgets.QLabel("Ma√üstab:"))
            h_layout.addWidget(self.scale_combo)
            parent_layout.insertLayout(idx, h_layout)
            
            # Add Canton Selection (under scale)
            canton_h = QtWidgets.QHBoxLayout()
            canton_h.addWidget(QtWidgets.QLabel("Kanton:"))
            self.combo_canton = QtWidgets.QComboBox()
            canton_h.addWidget(self.combo_canton)
            
            # Button to refresh canton list
            self.btn_refresh_canton = QtWidgets.QPushButton("üîÑ")
            self.btn_refresh_canton.setFixedWidth(30)
            self.btn_refresh_canton.setToolTip("Kantone neu laden")
            self.btn_refresh_canton.clicked.connect(self.refresh_canton_list)
            canton_h.addWidget(self.btn_refresh_canton)
            parent_layout.insertLayout(idx + 1, canton_h)
            
            # Populate canton list on startup
            self.refresh_canton_list()
        
        self.exportButton.clicked.connect(self.on_export_clicked)
        self.areaSelectButton.clicked.connect(self.on_area_select_clicked)
        
        # Hide area select button - we use mode-specific buttons instead
        # But KEEP export button visible to access the mode-selection dialog
        self.areaSelectButton.setVisible(False)
        
        self.current_geometry = None
        self.current_mode = None  # Track which mode is active
        self.current_dialog = None  # Store reference to open dialog
        self.selection_rb = None
        self.rect_tool = None

    def closeEvent(self, event):
        self._clear_selection_visual()
        self.closingPlugin.emit()
        event.accept()
    
    def refresh_canton_list(self):
        """Detect existing Kanton_* groups in the project"""
        self.combo_canton.clear()
        
        root = QgsProject.instance().layerTreeRoot()
        cantons = []
        
        for child in root.children():
            if child.name().startswith("Kanton_"):
                canton_name = child.name().replace("Kanton_", "")
                cantons.append(canton_name)
        
        if cantons:
            for canton in sorted(cantons):
                self.combo_canton.addItem(canton, canton)
        else:
            self.combo_canton.addItem("(Keine Kanton-Gruppen gefunden)", None)

    def get_selected_scale(self):
        txt = self.scale_combo.currentText()
        try:
            return float(txt.split(":")[1])
        except:
            return 500.0

    def on_scale_changed(self):
        scale = self.get_selected_scale()
        if self.rect_tool:
            self.rect_tool.set_target_scale(scale)
        if self.current_geometry:
            self._clear_selection_visual()
            self.current_geometry = None
            QtWidgets.QMessageBox.information(self, "Info", "Ma√üstab ge√§ndert. Bitte Bereich neu ausw√§hlen.")
    
    def refresh_canton_list(self):
        """Detect existing Kanton_* groups in the project and populate dropdown"""
        project = QgsProject.instance()
        root = project.layerTreeRoot()
        
        # Find all groups that start with "Kanton_"
        canton_groups = []
        for group in root.findGroups():
            if group.name().startswith("Kanton_"):
                canton_name = group.name().replace("Kanton_", "")
                canton_groups.append((canton_name, group.name()))
        
        # Update combo box
        current_selection = self.combo_canton.currentData()
        self.combo_canton.clear()
        
        if canton_groups:
            for canton_name, group_name in sorted(canton_groups):
                self.combo_canton.addItem(canton_name, group_name)
            
            # Restore previous selection if still available
            if current_selection:
                index = self.combo_canton.findData(current_selection)
                if index >= 0:
                    self.combo_canton.setCurrentIndex(index)
            
            print(f"DEBUG: Found {len(canton_groups)} canton groups: {[c[0] for c in canton_groups]}")
        else:
            self.combo_canton.addItem("Keine Kantone gefunden", None)
            print("DEBUG: No Kanton_* groups found in project")

    def on_area_select_clicked(self):
        self._clear_selection_visual()
        scale = self.get_selected_scale()
        self.rect_tool = FixedFrameTool(
            iface.mapCanvas(),
            scale,
            self.process_selection
        )
        iface.mapCanvas().setMapTool(self.rect_tool)

    def process_selection(self, rectangle):
        self.current_geometry = rectangle
        self._draw_persistent_selection(rectangle)
        
        # Show dialog again after area selection
        if self.current_dialog:
            self.current_dialog.show()
            self.current_dialog.raise_()
            self.current_dialog.activateWindow()
        
        # Enable export button for current mode (via dialog reference)
        if self.current_dialog:
            if self.current_mode == "batch":
                self.current_dialog.btn_export_batch.setEnabled(True)
            elif self.current_mode == "overlay":
                self.current_dialog.btn_export_overlay.setEnabled(True)
            elif self.current_mode == "layout":
                self.current_dialog.btn_export_layout.setEnabled(True)
            elif self.current_mode == "dxf":
                self.current_dialog.btn_export_dxf.setEnabled(True)
        
    def _draw_persistent_selection(self, rect):
        self._clear_selection_visual()
        self.selection_rb = QgsRubberBand(iface.mapCanvas(), QgsWkbTypes.PolygonGeometry)
        self.selection_rb.setColor(QColor(255, 0, 0))
        self.selection_rb.setWidth(2)
        self.selection_rb.setFillColor(QColor(255, 64, 0, 40))
        self.selection_rb.setToGeometry(QgsGeometry.fromRect(rect), None)

    def _clear_selection_visual(self):
        if self.selection_rb:
            iface.mapCanvas().scene().removeItem(self.selection_rb)
            self.selection_rb = None
    
    def on_area_select_mode(self, mode):
        """Area selection for specific mode - resets area when switching modes"""
        # Reset area selection if switching modes
        if self.current_mode != mode:
            self._clear_selection_visual()
            self.current_geometry = None
            # Disable all export buttons (via dialog reference)
            if self.current_dialog:
                self.current_dialog.btn_export_batch.setEnabled(False)
                self.current_dialog.btn_export_overlay.setEnabled(False)
                self.current_dialog.btn_export_layout.setEnabled(False)
                self.current_dialog.btn_export_dxf.setEnabled(False)
        
        self.current_mode = mode
        
        # Hide dialog while selecting area on map
        if self.current_dialog:
            self.current_dialog.hide()
            # Get page size from dialog
            page_width, page_height = self.current_dialog.get_page_size()
        else:
            # Fallback to default if dialog not available
            page_width, page_height = 150, 120
        
        scale = self.get_selected_scale()
        self.rect_tool = FixedFrameTool(
            iface.mapCanvas(),
            scale,
            self.process_selection,
            width_mm=page_width,
            height_mm=page_height
        )
        iface.mapCanvas().setMapTool(self.rect_tool)

    def on_export_clicked(self):
        # Open export dialog - area selection check happens in mode-specific export buttons
        # Dialog is modeless (non-blocking) so user can interact with map
        dialog = LayerSelectDialog(self)
        self.current_dialog = dialog  # Store reference for button access
        
        # Show modeless dialog (non-blocking)
        dialog.show()
    
    def on_export_mode(self, mode):
        """Export for specific mode - called from dialog's export buttons"""
        if not self.current_geometry:
            QtWidgets.QMessageBox.warning(self, "Fehler", "Bitte w√§hlen Sie zuerst einen Bereich aus!")
            return
        
        if not self.current_dialog:
            return
        
        # Get ALL settings from dialog BEFORE closing it
        fmt = self.current_dialog.get_format()
        dpi = self.current_dialog.get_dpi()
        scale = self.get_selected_scale()
        
        # Get mode-specific data based on mode
        if mode == "batch":
            selected_ids = self.current_dialog.get_batch_layers()
            page_width, page_height = self.current_dialog.get_page_size()
        elif mode == "overlay":
            cfg = self.current_dialog.get_overlay_config()
            page_width, page_height = self.current_dialog.get_page_size()
        elif mode == "layout":
            cfg = self.current_dialog.get_layout_config()
        elif mode == "dxf":
            dxf_layer_ids = self.current_dialog.get_dxf_layers()

        # 2. Directory Selection
        out_dir = QtWidgets.QFileDialog.getExistingDirectory(self, "Speicherort w√§hlen")
        if not out_dir:
            return

        # Close dialog and clear reference AFTER reading all values
        self.current_dialog.close()
        self.current_dialog = None

        # Setup Progress Dialog
        progress = QtWidgets.QProgressDialog("Exportiere...", "Abbrechen", 0, 100, self)
        progress.setWindowModality(Qt.WindowModal)
        progress.setMinimumDuration(0)
        progress.setValue(0)

        # 3. Export Logic based on mode
        if mode == "batch":
            if not selected_ids:
                QtWidgets.QMessageBox.information(self, "Hinweis", "Bitte mindestens einen Layer ausw√§hlen!")
                return
            
            total = len(selected_ids)
            progress.setMaximum(total)
            
            count = 0
            for i, lid in enumerate(selected_ids):
                if progress.wasCanceled(): break
                layer = QgsProject.instance().mapLayer(lid)
                if layer:
                    progress.setLabelText(f"Exportiere Layer: {layer.name()}")
                    self.export_layout(
                        layers=[layer], 
                        opacities=[1.0], 
                        rectangle=self.current_geometry, 
                        scale=scale, 
                        out_dir=out_dir, 
                        fmt=fmt, 
                        dpi=dpi, 
                        filename_prefix=layer.name(),
                        page_width=page_width,
                        page_height=page_height
                    )
                    count += 1
                progress.setValue(i + 1)
            
            if not progress.wasCanceled():
                QtWidgets.QMessageBox.information(self, "Erfolg", f"{count} Dateien wurden exportiert.")

        elif mode == "overlay":
            base_layer = QgsProject.instance().mapLayer(cfg["base_id"])
            overlay_ids = cfg["overlay_ids"]
            
            if not base_layer: return
            if not overlay_ids:
                QtWidgets.QMessageBox.information(self, "Hinweis", "Bitte mindestens einen Overlay-Layer ausw√§hlen!")
                return

            total = len(overlay_ids)
            progress.setMaximum(total)

            count = 0
            for i, ov_id in enumerate(overlay_ids):
                if progress.wasCanceled(): break
                overlay_layer = QgsProject.instance().mapLayer(ov_id)
                if overlay_layer:
                    progress.setLabelText(f"Exportiere Overlay: {overlay_layer.name()}")
                    self.export_layout(
                        layers=[base_layer, overlay_layer],
                        opacities=[1.0, cfg["opacity"]],
                        rectangle=self.current_geometry,
                        scale=scale,
                        out_dir=out_dir,
                        fmt=fmt,
                        dpi=dpi,
                        filename_prefix=f"Overlay_{base_layer.name()}_{overlay_layer.name()}",
                        page_width=page_width,
                        page_height=page_height
                    )
                    count += 1
                progress.setValue(i + 1)
                QtWidgets.QMessageBox.information(self, "Erfolg", f"{count} Overlay-Bilder erfolgreich exportiert.")
            
        elif mode == "layout":
            cfg = self.current_dialog.get_layout_config()
            base_id = cfg["base_id"]
            overlay_ids = cfg["overlay_ids"]
            template_path = cfg["template_path"]
            opacity = cfg["opacity"]
            debug_mode = cfg.get("debug_mode", False)
            user_info = cfg.get("user_info", {})
            
            if not base_id: 
                 QtWidgets.QMessageBox.information(self, "Hinweis", "Bitte Basis-Layer ausw√§hlen!")
                 return
            
            base_layer = QgsProject.instance().mapLayer(base_id)
            # Allow empty overlay_ids (user might want empty slots)
            # if not overlay_ids: ...
            
            progress.setMaximum(0) # Indeterminate for single file generation
            progress.setLabelText("Generiere Layout-Bogen...")
            
            result = self.export_overview_layout(
                base_layer=base_layer, 
                overlay_ids=overlay_ids,
                opacity=cfg["opacity"],
                info=cfg,
                rectangle=self.current_geometry,
                scale=scale,
                out_dir=out_dir,
                fmt=fmt,
                dpi=dpi,
                debug=cfg["debug"]
            )
            progress.setValue(100)
            
            if cfg["debug"]:
                QtWidgets.QMessageBox.information(self, "Debug", "Layout wurde ge√∂ffnet. Bitte pr√ºfe die Positionierung und schicke mir Screenshots!")
                if result:
                    QtWidgets.QMessageBox.information(self, "Erfolg", f"Layout erfolgreich gespeichert!")
        
        elif mode == "dxf":
            dxf_layer_ids = self.current_dialog.get_dxf_layers()
            
            if not dxf_layer_ids:
                QtWidgets.QMessageBox.information(self, "Hinweis", "Bitte mindestens einen Layer f√ºr DXF-Export ausw√§hlen!")
                return
            
            if len(dxf_layer_ids) > 5:
                QtWidgets.QMessageBox.warning(self, "Fehler", "Maximal 5 Layer k√∂nnen gleichzeitig exportiert werden.")
                return
            
            progress.setMaximum(0)  # Indeterminate progress
            progress.setLabelText(f"Exportiere {len(dxf_layer_ids)} Layer als DXF...")
            
            # Filename: Wenn nur 1 Layer -> Layer-Name, sonst "Multi"
            if len(dxf_layer_ids) == 1:
                layer = QgsProject.instance().mapLayer(dxf_layer_ids[0])
                filename = layer.name() if layer else "export"
            else:
                filename = f"MultiLayer_{len(dxf_layer_ids)}_Layers"
            
            success = self.export_dxf(
                layer_ids=dxf_layer_ids,
                rectangle=self.current_geometry,
                out_dir=out_dir,
                filename=filename
            )
            
            progress.setValue(100)
            
            if success:
                QtWidgets.QMessageBox.information(self, "Erfolg", 
                    f"DXF-Export erfolgreich!\n{len(dxf_layer_ids)} Layer exportiert.")
        
        progress.close()

    def export_layout(self, layers, opacities, rectangle, scale, out_dir, fmt, dpi, filename_prefix, page_width=150, page_height=120):
        # Create a print layout
        project = QgsProject.instance()
        layout = QgsPrintLayout(project)
        layout.initializeDefaults()
        
        # Set page size (now dynamic)
        page = layout.pageCollection().pages()[0]
        page.setPageSize(QgsLayoutSize(page_width, page_height, QgsUnitTypes.LayoutMillimeters))
        
        # Add Maps (Stacked)
        # We add them in order. First layer is bottom.
        linked_map = None
        
        for i, layer in enumerate(layers):
            map_item = QgsLayoutItemMap(layout)
            map_item.setRect(QRectF(0, 0, page_width, page_height))  # Full page - now dynamic
            map_item.setLayers([layer])
            map_item.setExtent(rectangle)
            map_item.setScale(scale)
            map_item.setBackgroundColor(QColor(255, 255, 255, 0)) # Transparent
            
            # Set Opacity
            # QgsLayoutItemMap doesn't have simple opacity setter for content, 
            # but we can set item opacity.
            map_item.setItemOpacity(opacities[i])
            
            layout.addLayoutItem(map_item)
            if i == 0:
                linked_map = map_item # Link decorations to base map
        
        # Add Decorations (with relative positioning)
        if linked_map:
            # Scale Bar - bottom left (5mm from left, 10mm from bottom)
            scale_bar = QgsLayoutItemScaleBar(layout)
            scale_bar.setStyle('Single Box')
            scale_bar.setLinkedMap(linked_map)
            scale_bar.applyDefaultSize()
            scale_bar.attemptMove(QgsLayoutPoint(5, page_height - 10, QgsUnitTypes.LayoutMillimeters))
            layout.addLayoutItem(scale_bar)
            
            # North Arrow - top right (15mm from right, 5mm from top)
            arrow = QgsLayoutItemPicture(layout)
            arrow.setPicturePath(":/images/north_arrows/layout_default_north_arrow.svg")
            arrow.attemptResize(QgsLayoutSize(10, 10, QgsUnitTypes.LayoutMillimeters))
            arrow.attemptMove(QgsLayoutPoint(page_width - 15, 5, QgsUnitTypes.LayoutMillimeters))
            layout.addLayoutItem(arrow)
            
            # Label - top left (5mm from edges)
            label = QgsLayoutItemLabel(layout)
            label.setText(filename_prefix)
            label.setFont(QtGui.QFont("Arial", 10))
            label.adjustSizeToText()
            label.attemptMove(QgsLayoutPoint(5, 5, QgsUnitTypes.LayoutMillimeters))
            layout.addLayoutItem(label)

        # Export
        safe_name = "".join([c for c in filename_prefix if c.isalpha() or c.isdigit() or c in (' ', '-', '_')]).strip()
        
        exporter = QgsLayoutExporter(layout)
        
        if fmt == "PDF":
            filename = f"{safe_name}.pdf"
            path = os.path.join(out_dir, filename)
            settings = QgsLayoutExporter.PdfExportSettings()
            settings.dpi = dpi
            exporter.exportToPdf(path, settings)
        elif fmt == "PNG":
            filename = f"{safe_name}.png"
            path = os.path.join(out_dir, filename)
            settings = QgsLayoutExporter.ImageExportSettings()
            settings.dpi = dpi
            exporter.exportToImage(path, settings)
        else: # JPG
            filename = f"{safe_name}.jpg"
            path = os.path.join(out_dir, filename)
            settings = QgsLayoutExporter.ImageExportSettings()
            settings.dpi = dpi
            exporter.exportToImage(path, settings)
            
        print(f"Exportiert: {path}")

    def export_overview_layout(self, base_layer, overlay_ids, opacity, info, rectangle, scale, out_dir, fmt, dpi, debug=False):
        project = QgsProject.instance()
        layout = QgsPrintLayout(project)
        layout.initializeDefaults()
        
        template_path = info.get('template')
        
        # Try to resolve template path
        if template_path:
            if not os.path.exists(template_path):
                # Try in templates dir
                default_dir = os.path.join(os.path.dirname(__file__), 'templates')
                candidate = os.path.join(default_dir, template_path)
                if os.path.exists(candidate):
                    template_path = candidate
                elif os.path.exists(candidate + ".qpt"):
                    template_path = candidate + ".qpt"
            
            if not os.path.exists(template_path):
                QtWidgets.QMessageBox.warning(None, "Fehler", f"Vorlage nicht gefunden:\n{template_path}")
                return None

        if template_path:
            # --- Template Mode ---
            print(f"Lade Vorlage: {template_path}")
            with open(template_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            doc = QDomDocument()
            doc.setContent(content)
            loaded = layout.loadFromTemplate(doc, QgsReadWriteContext())
            if not loaded:
                 QtWidgets.QMessageBox.warning(None, "Fehler", "Vorlage konnte nicht geladen werden (ung√ºltiges Format?).")
                 return None
            
            # 1. Update Text Labels
            # Map of ID -> Text Value
            # Based on user request and previous context:
            # K√ºrzel -> "Gez"
            # Date -> "Dat"
            # Title -> "project_nr" (or "Title"?) -> User said "Projektnummer/Projekttitel" for Title field.
            # ProjectName -> "layout_name"
            
            text_map = {
                'K√ºrzel': info.get('kuerzel', ''),  # Primary ID
                'Gez': info.get('kuerzel', ''),      # Fallback
                'Dat': info.get('date', ''),
                'Date': info.get('date', ''),        # Fallback
                'project_nr': info.get('title', ''),
                'Title': info.get('title', ''),      # Fallback
                'ProjectNumber': info.get('title', ''), # Fallback
                'layout_name': info.get('project_name', ''),
                'ProjectName': info.get('project_name', '')  # Primary ID
            }
            
            for item_id, text in text_map.items():
                if not text: continue
                item = layout.itemById(item_id)
                if isinstance(item, QgsLayoutItemLabel):
                    item.setText(text)
            
            # 2. Handle MainMap Slots (MainMap1, MainMap2, ...)
            # User has Map items with IDs: MainMap1, MainMap2, ..., MainMap8
            
            # Track opacity changes to restore later
            opacity_restore_list = []
            
            # overlay_ids is a list of 8 items (Layer ID or None) from dropdowns
            for i, lid in enumerate(overlay_ids):
                slot_id = f"MainMap{i+1}"
                slot = layout.itemById(slot_id)
                
                if isinstance(slot, QgsLayoutItemMap):
                    if lid:
                        overlay_layer = project.mapLayer(lid)
                        if overlay_layer:
                            # Set extent and scale
                            slot.setExtent(rectangle)
                            slot.setScale(scale)
                            slot.setFollowVisibilityPreset(False)
                            
                            # Store original opacity for restoration later
                            original_opacity = overlay_layer.opacity()
                            opacity_restore_list.append((overlay_layer, original_opacity))
                            
                            # Set the overlay layer's opacity
                            overlay_layer.setOpacity(opacity)
                            
                            # Set both layers
                            slot.setLayers([overlay_layer, base_layer])
                            slot.setItemOpacity(1.0)
                            
                            # --- ADD TITLE ABOVE MAP ---
                            # Get map position and size
                            map_pos = slot.positionWithUnits()
                            map_size = slot.sizeWithUnits()
                            
                            # Create title label with overlay layer name
                            title_label = QgsLayoutItemLabel(layout)
                            title_label.setText(overlay_layer.name())
                            title_label.setFont(QtGui.QFont(self.TITLE_FONT_FAMILY, self.TITLE_FONT_SIZE, QtGui.QFont.Bold))
                            title_label.adjustSizeToText()
                            
                            # Position: above the map (8mm margin)
                            title_label.attemptMove(QgsLayoutPoint(
                                map_pos.x(), 
                                map_pos.y() - 8,
                                QgsUnitTypes.LayoutMillimeters
                            ))
                            layout.addLayoutItem(title_label)
                            
                            # --- ADD LEGEND BELOW MAP ---
                            legend = QgsLayoutItemLegend(layout)
                            legend.setLinkedMap(slot)
                            
                            # Configure legend to show only overlay layer symbology (without layer name)
                            legend.setAutoUpdateModel(False)
                            legend_model = legend.model()
                            legend_model.rootGroup().clear()
                            
                            # Add layer to legend
                            layer_tree_layer = legend_model.rootGroup().addLayer(overlay_layer)
                            
                            # Hide the layer name by setting it to empty string
                            # This avoids duplication with the title above the map
                            layer_tree_layer.setName("")
                            
                            # Compact legend style - no titles, minimal margins
                            legend.setTitle("")  # No legend title
                            legend.rstyle(QgsLegendStyle.Title).setMargin(QgsLegendStyle.Bottom, 0)
                            legend.rstyle(QgsLegendStyle.Group).setMargin(QgsLegendStyle.Top, 0)
                            legend.rstyle(QgsLegendStyle.Subgroup).setMargin(QgsLegendStyle.Top, 0)
                            
                            # Further compactness: minimize symbol spacing
                            legend.rstyle(QgsLegendStyle.Symbol).setMargin(QgsLegendStyle.Top, 1)
                            legend.rstyle(QgsLegendStyle.SymbolLabel).setMargin(QgsLegendStyle.Top, 1)
                            
                            # Position: below the map (2mm margin)
                            legend.attemptMove(QgsLayoutPoint(
                                map_pos.x(),
                                map_pos.y() + map_size.height() + 2,
                                QgsUnitTypes.LayoutMillimeters
                            ))
                            
                            # Adjust legend size to fit content
                            legend.adjustBoxSize()
                            
                            layout.addLayoutItem(legend)
                        else:
                            slot.setLayers([])
                    else:
                        # Empty slot - make completely invisible
                        slot.setFollowVisibilityPreset(False)
                        slot.setLayers([])
                        # Make the entire item invisible
                        slot.setItemOpacity(0.0)
                        # Also set white background just in case
                        slot.setBackgroundEnabled(True)
                        slot.setBackgroundColor(QColor(255, 255, 255, 255))
                    
            # Clear remaining slots if template has more than 8?
            # Not strictly necessary if we only support 8 dropdowns.
            
            # 3. Fix LayoutBSS SVG Path
            # Ensure the SVG path is correct (absolute path to templates dir)
            layout_bss_item = layout.itemById("LayoutBSS")
            if isinstance(layout_bss_item, QgsLayoutItemPicture):
                svg_path = os.path.join(os.path.dirname(__file__), 'templates', 'LayoutBSS.svg')
                if os.path.exists(svg_path):
                    layout_bss_item.setPicturePath(svg_path)
                else:
                    print(f"Warnung: LayoutBSS.svg nicht gefunden unter {svg_path}")

        else:
            # Fallback to old programmatic mode if no template (should not happen with new UI check)
             QtWidgets.QMessageBox.warning(None, "Fehler", "Keine Vorlage ausgew√§hlt!")
             return None

        # Export or Open
        if debug:
            # Layout Namen setzen
            layout_name = f"Debug_Layout_{info.get('title', 'Unknown')}"
            layout.setName(layout_name)
            
            # Zum Manager hinzuf√ºgen
            project.layoutManager().addLayout(layout)
        
            # Hole Layout vom Manager zur√ºck (frische Referenz)
            from qgis.PyQt.QtCore import QTimer
        
            def open_layout():
                fresh = project.layoutManager().layoutByName(layout_name)
                if fresh:
                    iface.openLayoutDesigner(fresh)
                    print("Layout ge√∂ffnet im Debug-Modus")
                else:
                    print("FEHLER: Layout konnte nicht abgerufen werden")
        
            # Verz√∂gertes √ñffnen (100ms warten)
            QTimer.singleShot(100, open_layout)
            return layout
        else:
            # Use document_name if provided, otherwise fall back to title
            doc_name = info.get('document_name', '').strip()
            if not doc_name:
                doc_name = info.get('title', 'export').strip()
            if not doc_name:
                doc_name = 'export'
            
            safe_name = "".join([c for c in doc_name if c.isalnum() or c in (' ', '-', '_')]).strip()
            filename = f"{safe_name}.{fmt.lower()}"
            path = os.path.join(out_dir, filename)
        
            exporter = QgsLayoutExporter(layout)
            if fmt == "PDF":
                settings = QgsLayoutExporter.PdfExportSettings()
                settings.dpi = dpi
                result = exporter.exportToPdf(path, settings)
            else:
                # For image formats (PNG, JPG, etc.)
                settings = QgsLayoutExporter.ImageExportSettings()
                settings.dpi = dpi
                # Make sure path has correct extension
                if not path.lower().endswith(f'.{fmt.lower()}'):
                    base_path = os.path.splitext(path)[0]
                    path = f"{base_path}.{fmt.lower()}"
                result = exporter.exportToImage(path, settings)
            
            # Restore layer opacities after export
            for layer, original_opacity in opacity_restore_list:
                layer.setOpacity(original_opacity)
            
            # Check export result
            if result == QgsLayoutExporter.Success:
                print(f"Layout exportiert: {path}")
            else:
                error_messages = {
                    QgsLayoutExporter.FileError: "Datei konnte nicht geschrieben werden",
                    QgsLayoutExporter.PrintError: "Druckfehler",
                    QgsLayoutExporter.MemoryError: "Nicht genug Speicher",
                    QgsLayoutExporter.IteratorError: "Iterator-Fehler",
                    QgsLayoutExporter.Canceled: "Export abgebrochen"
                }
                error_msg = error_messages.get(result, f"Unbekannter Fehler ({result})")
                print(f"FEHLER beim Export: {error_msg}")
            
            return None
    
    def export_dxf(self, layer_ids, rectangle, out_dir, filename):
        """
        Exportiert 1-5 Vektor-Layer als DXF.
        Wenn 1 Layer: Einzelexport mit QgsVectorFileWriter
        Wenn 2-5 Layer: Kombinierter Export mit QgsDxfExport
        """
        from qgis.core import (QgsVectorFileWriter, QgsDxfExport, 
                               QgsCoordinateReferenceSystem, QgsMapSettings, 
                               QgsRectangle, QgsProject, QgsMapLayer)
        
        # Validierung: 1-5 Layer
        if not layer_ids or len(layer_ids) < 1:
            QtWidgets.QMessageBox.warning(None, "Fehler", 
                "Bitte mindestens 1 Layer f√ºr DXF-Export ausw√§hlen.")
            return False
        
        if len(layer_ids) > 5:
            QtWidgets.QMessageBox.warning(None, "Fehler", 
                "Maximal 5 Layer k√∂nnen gleichzeitig exportiert werden.")
            return False
        
        # Layer-Objekte laden
        layers = []
        for layer_id in layer_ids:
            layer = QgsProject.instance().mapLayer(layer_id)
            if layer and layer.type() == QgsMapLayer.VectorLayer:
                layers.append(layer)
            else:
                print(f"Warnung: Layer {layer_id} nicht gefunden oder kein Vektor-Layer")
        
        if not layers:
            QtWidgets.QMessageBox.warning(None, "Fehler", 
                "Keine g√ºltigen Vektor-Layer zum Exportieren gefunden.")
            return False
        
        # Dateiname vorbereiten
        dxf_path = os.path.join(out_dir, f"{filename}.dxf")
        
        try:
            if len(layers) == 1:
                # EINZELNER LAYER: QgsVectorFileWriter verwenden
                layer = layers[0]
                
                # Save options
                save_options = QgsVectorFileWriter.SaveVectorOptions()
                save_options.driverName = "DXF"
                save_options.fileEncoding = "UTF-8"
                save_options.skipAttributeCreation = True  # DXF unterst√ºtzt keine benutzerdefinierten Felder
                
                # Filter nach Rectangle wenn vorhanden
                if rectangle:
                    save_options.filterExtent = rectangle
                
                # Export
                error = QgsVectorFileWriter.writeAsVectorFormatV2(
                    layer,
                    dxf_path,
                    QgsProject.instance().transformContext(),
                    save_options
                )
                
                if error[0] == QgsVectorFileWriter.NoError:
                    print(f"‚úì DXF erfolgreich exportiert: {dxf_path}")
                    return True
                else:
                    QtWidgets.QMessageBox.warning(None, "Fehler", 
                        f"DXF-Export fehlgeschlagen:\n{error[1]}")
                    return False
                    
            else:
                # MEHRERE LAYER (2-5): QgsDxfExport verwenden
                dxf_export = QgsDxfExport()
                dxf_export.setDestinationCrs(QgsCoordinateReferenceSystem("EPSG:2056"))
                
                # Layer hinzuf√ºgen - QGIS 3.x verwendet addLayers, nicht setLayers
                for layer in layers:
                    dxf_export.addLayers([QgsDxfExport.DxfLayer(layer)])
                
                # Extent setzen
                if rectangle:
                    dxf_export.setExtent(rectangle)
                else:
                    # Gesamten Extent aller Layer verwenden
                    combined_extent = QgsRectangle()
                    combined_extent.setMinimal()
                    for layer in layers:
                        combined_extent.combineExtentWith(layer.extent())
                    dxf_export.setExtent(combined_extent)
                
                # MapSettings f√ºr Symbologie (optional)
                map_settings = QgsMapSettings()
                map_settings.setDestinationCrs(QgsCoordinateReferenceSystem("EPSG:2056"))
                map_settings.setExtent(dxf_export.extent())
                dxf_export.setMapSettings(map_settings)
                
                # Export durchf√ºhren - QFile verwenden statt String-Pfad
                from qgis.PyQt.QtCore import QFile, QIODevice
                
                output_file = QFile(dxf_path)
                if not output_file.open(QIODevice.WriteOnly):
                    QtWidgets.QMessageBox.warning(None, "Fehler", 
                        f"Datei kann nicht zum Schreiben ge√∂ffnet werden:\n{dxf_path}")
                    return False
                
                result = dxf_export.writeToFile(output_file, "UTF-8")
                output_file.close()
                
                if result == QgsDxfExport.ExportResult.Success:
                    print(f"‚úì Multi-Layer DXF erfolgreich exportiert: {dxf_path}")
                    return True
                else:
                    error_messages = {
                        QgsDxfExport.ExportResult.DeviceNotWritableError: "Datei kann nicht geschrieben werden",
                        QgsDxfExport.ExportResult.EmptyExtent: "Leerer Exportbereich"
                    }
                    error_msg = error_messages.get(result, f"Unbekannter Fehler ({result})")
                    QtWidgets.QMessageBox.warning(None, "Fehler", 
                        f"Multi-Layer DXF-Export fehlgeschlagen:\n{error_msg}")
                    return False
                    
        except Exception as e:
            QtWidgets.QMessageBox.critical(None, "Fehler", 
                f"Fehler beim DXF-Export:\n{str(e)}")
            print(f"Exception in export_dxf: {e}")
            import traceback
            traceback.print_exc()
            return False